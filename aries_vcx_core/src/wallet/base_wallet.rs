use std::{collections::HashMap, sync::Arc};

use async_trait::async_trait;

use super::structs_io::UnpackMessageOutput;
#[cfg(feature = "vdrtools_wallet")]
use crate::WalletHandle;
use crate::{errors::error::VcxCoreResult, utils::async_fn_iterator::AsyncFnIterator};

/// Trait defining standard 'wallet' related functionality. The APIs, including
/// input and output types are loosely based off the indy Wallet API:
/// see: <https://github.com/hyperledger/indy-sdk/blob/main/libindy/src/api/wallet.rs>
#[async_trait]
pub trait BaseWallet: std::fmt::Debug + Send + Sync {
    #[cfg(feature = "vdrtools_wallet")]
    fn get_wallet_handle(&self) -> WalletHandle;

    // ----- DIDs
    async fn create_and_store_my_did(
        &self,
        seed: Option<&str>,
        kdf_method_name: Option<&str>,
    ) -> VcxCoreResult<(String, String)>;

    async fn key_for_local_did(&self, did: &str) -> VcxCoreResult<String>;

    // returns new temp_verkey and remembers it internally
    async fn replace_did_keys_start(&self, target_did: &str) -> VcxCoreResult<String>;

    // replaces the `target_did`'s current verkey with the one last generated by
    // `replace_did_keys_start`
    async fn replace_did_keys_apply(&self, target_did: &str) -> VcxCoreResult<()>;

    // ---- records

    async fn add_wallet_record(
        &self,
        xtype: &str,
        id: &str,
        value: &str,
        tags: Option<HashMap<String, String>>,
    ) -> VcxCoreResult<()>;

    async fn get_wallet_record(
        &self,
        xtype: &str,
        id: &str,
        options: &str,
    ) -> VcxCoreResult<String>;

    async fn get_wallet_record_value(&self, xtype: &str, id: &str) -> VcxCoreResult<String>;

    async fn delete_wallet_record(&self, xtype: &str, id: &str) -> VcxCoreResult<()>;

    async fn update_wallet_record_value(
        &self,
        xtype: &str,
        id: &str,
        value: &str,
    ) -> VcxCoreResult<()>;

    async fn add_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tags: HashMap<String, String>,
    ) -> VcxCoreResult<()>;

    async fn update_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tags: HashMap<String, String>,
    ) -> VcxCoreResult<()>;

    async fn delete_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tag_names: &str,
    ) -> VcxCoreResult<()>;

    async fn iterate_wallet_records(
        &self,
        xtype: &str,
        query: &str,
        options: &str,
    ) -> VcxCoreResult<Box<dyn AsyncFnIterator<Item = VcxCoreResult<String>>>>;

    // ---- crypto

    async fn sign(&self, my_vk: &str, msg: &[u8]) -> VcxCoreResult<Vec<u8>>;

    async fn verify(&self, vk: &str, msg: &[u8], signature: &[u8]) -> VcxCoreResult<bool>;

    async fn pack_message(
        &self,
        sender_vk: Option<&str>,
        receiver_keys: &str,
        msg: &[u8],
    ) -> VcxCoreResult<Vec<u8>>;

    async fn unpack_message(&self, msg: &[u8]) -> VcxCoreResult<UnpackMessageOutput>;
}

/// TODO: Workaround to keep some bits and pieces (like libvcx) working with Arcs. Delete ASAP and
/// wash your hands after.
#[async_trait]
impl<W> BaseWallet for Arc<W>
where
    W: BaseWallet + ?Sized,
{
    #[cfg(feature = "vdrtools_wallet")]
    fn get_wallet_handle(&self) -> WalletHandle {
        (**self).get_wallet_handle()
    }

    // ----- DIDs
    async fn create_and_store_my_did(
        &self,
        seed: Option<&str>,
        kdf_method_name: Option<&str>,
    ) -> VcxCoreResult<(String, String)> {
        (**self)
            .create_and_store_my_did(seed, kdf_method_name)
            .await
    }

    async fn key_for_local_did(&self, did: &str) -> VcxCoreResult<String> {
        (**self).key_for_local_did(did).await
    }

    // returns new temp_verkey and remembers it internally
    async fn replace_did_keys_start(&self, target_did: &str) -> VcxCoreResult<String> {
        (**self).replace_did_keys_start(target_did).await
    }

    // replaces the `target_did`'s current verkey with the one last generated by
    // `replace_did_keys_start`
    async fn replace_did_keys_apply(&self, target_did: &str) -> VcxCoreResult<()> {
        (**self).replace_did_keys_apply(target_did).await
    }

    // ---- records

    async fn add_wallet_record(
        &self,
        xtype: &str,
        id: &str,
        value: &str,
        tags: Option<HashMap<String, String>>,
    ) -> VcxCoreResult<()> {
        (**self).add_wallet_record(xtype, id, value, tags).await
    }

    async fn get_wallet_record(
        &self,
        xtype: &str,
        id: &str,
        options: &str,
    ) -> VcxCoreResult<String> {
        (**self).get_wallet_record(xtype, id, options).await
    }

    async fn get_wallet_record_value(&self, xtype: &str, id: &str) -> VcxCoreResult<String> {
        (**self).get_wallet_record_value(xtype, id).await
    }

    async fn delete_wallet_record(&self, xtype: &str, id: &str) -> VcxCoreResult<()> {
        (**self).delete_wallet_record(xtype, id).await
    }

    async fn update_wallet_record_value(
        &self,
        xtype: &str,
        id: &str,
        value: &str,
    ) -> VcxCoreResult<()> {
        (**self).update_wallet_record_value(xtype, id, value).await
    }

    async fn add_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tags: HashMap<String, String>,
    ) -> VcxCoreResult<()> {
        (**self).add_wallet_record_tags(xtype, id, tags).await
    }

    async fn update_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tags: HashMap<String, String>,
    ) -> VcxCoreResult<()> {
        (**self).update_wallet_record_tags(xtype, id, tags).await
    }

    async fn delete_wallet_record_tags(
        &self,
        xtype: &str,
        id: &str,
        tag_names: &str,
    ) -> VcxCoreResult<()> {
        (**self)
            .delete_wallet_record_tags(xtype, id, tag_names)
            .await
    }

    async fn iterate_wallet_records(
        &self,
        xtype: &str,
        query: &str,
        options: &str,
    ) -> VcxCoreResult<Box<dyn AsyncFnIterator<Item = VcxCoreResult<String>>>> {
        (**self).iterate_wallet_records(xtype, query, options).await
    }

    // ---- crypto

    async fn sign(&self, my_vk: &str, msg: &[u8]) -> VcxCoreResult<Vec<u8>> {
        (**self).sign(my_vk, msg).await
    }

    async fn verify(&self, vk: &str, msg: &[u8], signature: &[u8]) -> VcxCoreResult<bool> {
        (**self).verify(vk, msg, signature).await
    }

    async fn pack_message(
        &self,
        sender_vk: Option<&str>,
        receiver_keys: &str,
        msg: &[u8],
    ) -> VcxCoreResult<Vec<u8>> {
        (**self).pack_message(sender_vk, receiver_keys, msg).await
    }

    async fn unpack_message(&self, msg: &[u8]) -> VcxCoreResult<UnpackMessageOutput> {
        (**self).unpack_message(msg).await
    }
}

#[async_trait]
pub trait AsyncFnIteratorCollect {
    type Item;

    async fn collect(&mut self) -> VcxCoreResult<Vec<Self::Item>>;
}

#[async_trait]
impl AsyncFnIteratorCollect for Box<dyn AsyncFnIterator<Item = VcxCoreResult<String>>> {
    type Item = String;

    async fn collect(&mut self) -> VcxCoreResult<Vec<Self::Item>> {
        let mut collection: Vec<Self::Item> = vec![];
        while let Some(res) = self.next().await {
            collection.push(res?);
        }
        Ok(collection)
    }
}
